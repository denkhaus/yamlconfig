package yamlconfig

import (
	"fmt"
	"github.com/globocom/config"
	"os/user"
	"path"
	"strconv"
)

type loadDefFn func(conf *Config)

type Config struct {
	defaults map[string]interface{}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
func (c *Config) ThrowKeyPanic(key string) {
	panic(fmt.Sprintf("config error: key %s not available", key))
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
//func (c *Config) ThrowConversionPanic(key string, value) {
//	panic(fmt.Sprintf("config error: key %s not available", key))
//}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
func (c *Config) stringSlice2IntSlice(value []string) (res []int) {

	for _, src := range value {
		if v, err := strconv.Atoi(src); err == nil {
			res = append(res, v)
		} else {
			//c.ThrowConversionPanic(key, src, int)
		}
	}
	return
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// GetInt
///////////////////////////////////////////////////////////////////////////////////////////////////////
func (c *Config) GetInt(key string) int {

	value, err := config.GetInt(key)
	if err != nil {
		if value, ok := c.defaults[key]; ok {
			return value.(int)
		}
		c.ThrowKeyPanic(key)
	}

	return value
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// GetInt
///////////////////////////////////////////////////////////////////////////////////////////////////////
func (c *Config) GetIntList(key string) []int {

	var res []int
	if value, err := config.GetList(key); err == nil {
		res = c.stringSlice2IntSlice(value)
	} else {
		if val, ok := c.defaults[key]; ok {
			res = val.([]int)
		} else {
			c.ThrowKeyPanic(key)
		}
	}

	return res
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// GetString
///////////////////////////////////////////////////////////////////////////////////////////////////////
func (c *Config) GetString(key string) string {
	value, err := config.GetString(key)

	if err != nil {
		if val, ok := c.defaults[key]; ok {
			res = val.(string)
		} else {
			c.ThrowKeyPanic(key)
		}
	}
	return value.(string)
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// GetStringList
///////////////////////////////////////////////////////////////////////////////////////////////////////
func (c *Config) GetStringList(key string) []string {

	if value, err := config.GetList(key); err != nil {
		if value, ok := c.defaults[key]; !ok {
			c.ThrowKeyPanic(key)
		}
	}
	return value.(string)
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
func (c *Config) SetDefault(key string, value interface{}) {
	c.defaults[key] = value
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
func (c *Config) writeDefConfigFile(filePath string) error {

	for key, value := range c.defaults {
		config.Set(key, value)
	}

	return config.WriteConfigFile(filePath, 644)
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Load
///////////////////////////////////////////////////////////////////////////////////////////////////////
func (c *Config) Load(loadDefaults loadDefFn, filePath string, watchConfig bool) error {

	var err error

	if len(filePath) == 0 {
		usr, err := user.Current()

		if err != nil {
			return err
		}

		filePath = path.Join(usr.HomeDir, "crfetchrc.yaml")
	}

	loadDefaults(c)
	if _, err := os.Stat(filePath); err == nil {
		if watchConfig {
			err = config.ReadAndWatchConfigFile(filePath)
			if err != nil {
				return err
			}

		} else {
			err = config.ReadConfigFile(filePath)
			if err != nil {
				return err
			}

		}
	} else {

		err = c.writeDefConfigFile(filePath)
		if err != nil {
			return err
		}

	}

	return nil
}
